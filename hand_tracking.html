<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport"
    content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="theme-color" content="#0f0c29">
  <title>Gesture Validation with DTW</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #0f0c29 0%, #302b63 50%, #24243e 100%);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
      color: #fff;
    }

    h1 {
      font-size: 2rem;
      margin-bottom: 8px;
      background: linear-gradient(90deg, #00d4ff, #7c3aed, #f472b6, #fbbf24);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .subtitle {
      font-size: 0.95rem;
      color: #a0aec0;
      margin-bottom: 15px;
    }

    /* File Upload Section */
    .upload-section {
      background: rgba(255, 255, 255, 0.08);
      border-radius: 15px;
      padding: 15px 25px;
      margin-bottom: 20px;
      display: flex;
      gap: 15px;
      align-items: center;
      flex-wrap: wrap;
      justify-content: center;
      border: 1px solid rgba(255, 255, 255, 0.15);
    }

    .upload-btn {
      display: flex;
      align-items: center;
      gap: 10px;
      background: linear-gradient(135deg, #7c3aed, #00d4ff);
      padding: 12px 24px;
      border-radius: 25px;
      cursor: pointer;
      font-weight: 500;
      transition: all 0.3s ease;
      border: none;
      color: #fff;
      font-size: 0.95rem;
    }

    .upload-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 20px rgba(124, 58, 237, 0.4);
    }

    input[type="file"] {
      display: none;
    }

    .gesture-info {
      color: #a0aec0;
      font-size: 0.9rem;
    }

    .gesture-name {
      color: #00d4ff;
      font-weight: 600;
    }

    /* Main Content */
    .main-content {
      display: flex;
      gap: 20px;
      flex-wrap: wrap;
      justify-content: center;
      align-items: flex-start;
    }

    /* Video Section */
    .video-section {
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .section-label {
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 1px;
      color: #a0aec0;
      margin-bottom: 10px;
    }

    .container {
      position: relative;
      border-radius: 20px;
      overflow: hidden;
      box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
      background: rgba(255, 255, 255, 0.05);
    }

    .container.recording {
      box-shadow: 0 0 0 4px #ef4444, 0 25px 50px -12px rgba(0, 0, 0, 0.5);
      animation: pulse-border 1s infinite;
    }

    @keyframes pulse-border {

      0%,
      100% {
        box-shadow: 0 0 0 4px #ef4444, 0 25px 50px -12px rgba(0, 0, 0, 0.5);
      }

      50% {
        box-shadow: 0 0 0 6px #f97316, 0 25px 50px -12px rgba(0, 0, 0, 0.5);
      }
    }

    #videoElement {
      display: block;
      transform: scaleX(-1);
    }

    #canvasElement {
      position: absolute;
      top: 0;
      left: 0;
      transform: scaleX(-1);
    }

    .recording-indicator {
      position: absolute;
      top: 15px;
      left: 15px;
      background: rgba(239, 68, 68, 0.9);
      padding: 8px 15px;
      border-radius: 20px;
      font-size: 0.85rem;
      font-weight: 600;
      display: none;
      align-items: center;
      gap: 8px;
    }

    .recording-indicator.active {
      display: flex;
    }

    .recording-dot {
      width: 10px;
      height: 10px;
      background: #fff;
      border-radius: 50%;
      animation: blink 1s infinite;
    }

    @keyframes blink {

      0%,
      100% {
        opacity: 1;
      }

      50% {
        opacity: 0.3;
      }
    }

    /* Controls */
    .controls {
      margin-top: 15px;
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      justify-content: center;
    }

    .record-btn {
      background: linear-gradient(135deg, #ef4444, #f97316);
      border: none;
      color: #fff;
      padding: 15px 35px;
      border-radius: 30px;
      cursor: pointer;
      font-size: 1rem;
      font-weight: 600;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .record-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 20px rgba(239, 68, 68, 0.4);
    }

    .record-btn.recording {
      background: linear-gradient(135deg, #10b981, #00d4ff);
    }

    .record-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    /* Reference Section */
    .reference-section {
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .reference-container {
      position: relative;
      border-radius: 20px;
      overflow: hidden;
      background: linear-gradient(135deg, rgba(124, 58, 237, 0.2), rgba(0, 212, 255, 0.2));
      border: 2px solid rgba(124, 58, 237, 0.5);
    }

    #referenceCanvas {
      display: block;
    }

    .playback-controls {
      margin-top: 10px;
      display: flex;
      gap: 8px;
    }

    .play-btn {
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.3);
      color: #fff;
      padding: 8px 16px;
      border-radius: 20px;
      cursor: pointer;
      font-size: 0.85rem;
      transition: all 0.3s ease;
    }

    .play-btn:hover {
      background: rgba(255, 255, 255, 0.2);
    }

    .play-btn.active {
      background: linear-gradient(135deg, #7c3aed, #00d4ff);
      border-color: transparent;
    }

    .play-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    /* Results Panel */
    .results-panel {
      background: rgba(255, 255, 255, 0.08);
      backdrop-filter: blur(20px);
      border: 1px solid rgba(255, 255, 255, 0.15);
      border-radius: 20px;
      padding: 25px;
      min-width: 320px;
      max-width: 380px;
    }

    .results-panel h2 {
      font-size: 1rem;
      color: #00d4ff;
      margin-bottom: 20px;
      text-align: center;
      text-transform: uppercase;
      letter-spacing: 2px;
    }

    /* Score Display */
    .score-display {
      text-align: center;
      margin-bottom: 20px;
      padding: 20px;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 15px;
    }

    .score-value {
      font-size: 4.5rem;
      font-weight: 700;
      line-height: 1;
    }

    .score-value.excellent {
      background: linear-gradient(135deg, #10b981, #00d4ff);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    .score-value.good {
      background: linear-gradient(135deg, #f59e0b, #fbbf24);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    .score-value.poor {
      background: linear-gradient(135deg, #ef4444, #f97316);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    .score-value.waiting {
      color: #a0aec0;
    }

    .score-label {
      font-size: 0.85rem;
      color: #a0aec0;
      margin-top: 8px;
    }

    .result-badge {
      display: inline-block;
      padding: 8px 20px;
      border-radius: 20px;
      font-size: 1rem;
      font-weight: 600;
      margin-top: 10px;
    }

    .result-badge.perfect {
      background: linear-gradient(135deg, #10b981, #00d4ff);
    }

    .result-badge.good {
      background: linear-gradient(135deg, #f59e0b, #fbbf24);
      color: #000;
    }

    .result-badge.needs-work {
      background: linear-gradient(135deg, #ef4444, #f97316);
    }

    /* Feedback Section */
    .feedback-section {
      margin-top: 20px;
    }

    .feedback-title {
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 1px;
      color: #a0aec0;
      margin-bottom: 10px;
    }

    .feedback-list {
      list-style: none;
    }

    .feedback-item {
      padding: 10px 15px;
      margin-bottom: 8px;
      border-radius: 10px;
      font-size: 0.9rem;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .feedback-item.success {
      background: rgba(16, 185, 129, 0.2);
      border: 1px solid rgba(16, 185, 129, 0.5);
    }

    .feedback-item.warning {
      background: rgba(245, 158, 11, 0.2);
      border: 1px solid rgba(245, 158, 11, 0.5);
    }

    .feedback-item.error {
      background: rgba(239, 68, 68, 0.2);
      border: 1px solid rgba(239, 68, 68, 0.5);
    }

    .feedback-icon {
      font-size: 1.2rem;
    }

    /* Status */
    .status-section {
      margin-top: 20px;
      display: flex;
      gap: 10px;
      justify-content: center;
    }

    .status-item {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 10px;
      padding: 10px 15px;
      text-align: center;
      min-width: 80px;
    }

    .status-item .label {
      font-size: 0.65rem;
      text-transform: uppercase;
      letter-spacing: 1px;
      color: #a0aec0;
      margin-bottom: 3px;
    }

    .status-item .value {
      font-size: 1.1rem;
      font-weight: 700;
    }

    .status-item.fps .value {
      color: #7c3aed;
    }

    .status-item.frames .value {
      color: #00d4ff;
    }

    .status-item.status .value {
      color: #10b981;
    }

    .status-item.status .value.loading {
      color: #f59e0b;
    }

    /* Instructions */
    .instructions {
      margin-top: 20px;
      max-width: 900px;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 12px;
      padding: 20px;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .instructions h3 {
      color: #00d4ff;
      margin-bottom: 15px;
      font-size: 1rem;
    }

    .steps {
      display: flex;
      gap: 20px;
      flex-wrap: wrap;
      justify-content: center;
    }

    .step {
      flex: 1;
      min-width: 200px;
      text-align: center;
      padding: 15px;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 10px;
    }

    .step-number {
      width: 30px;
      height: 30px;
      background: linear-gradient(135deg, #7c3aed, #00d4ff);
      border-radius: 50%;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-weight: 700;
      margin-bottom: 10px;
    }

    .step-text {
      color: #a0aec0;
      font-size: 0.9rem;
      line-height: 1.5;
    }

    /* ========== MOBILE RESPONSIVE ========== */
    @media (max-width: 768px) {
      body {
        padding: 10px;
      }

      h1 {
        font-size: 1.5rem;
      }

      .subtitle {
        font-size: 0.85rem;
        text-align: center;
      }

      .upload-section {
        padding: 12px 15px;
        flex-direction: column;
      }

      .upload-btn {
        padding: 12px 20px;
        font-size: 0.9rem;
      }

      .main-content {
        flex-direction: column;
        gap: 15px;
      }

      .container {
        border-radius: 15px;
      }

      #videoElement,
      #canvasElement {
        width: 100%;
        max-width: 360px;
        height: auto;
        aspect-ratio: 4/3;
      }

      .reference-container {
        border-radius: 15px;
      }

      #referenceCanvas {
        width: 100%;
        max-width: 280px;
        height: auto;
      }

      .record-btn {
        padding: 15px 30px;
        font-size: 1rem;
        width: 100%;
        max-width: 280px;
        justify-content: center;
      }

      .controls {
        flex-direction: column;
        align-items: center;
        width: 100%;
      }

      .results-panel {
        min-width: unset;
        max-width: 100%;
        width: 100%;
        padding: 20px;
      }

      .score-value {
        font-size: 3.5rem;
      }

      .feedback-item {
        font-size: 0.85rem;
        padding: 8px 12px;
      }

      .instructions {
        padding: 15px;
      }

      .steps {
        flex-direction: column;
        gap: 10px;
      }

      .step {
        min-width: unset;
        padding: 12px;
      }

      .status-section {
        flex-wrap: wrap;
      }

      .status-item {
        min-width: 70px;
        padding: 8px 12px;
      }

      .section-label {
        font-size: 0.75rem;
      }
    }

    @media (max-width: 480px) {
      h1 {
        font-size: 1.3rem;
      }

      .score-value {
        font-size: 3rem;
      }

      .instructions {
        display: none;
      }
    }

    /* ========== FULLSCREEN MOBILE MODE ========== */
    .fullscreen-mode body {
      padding: 0;
      overflow: hidden;
    }

    .fullscreen-mode .container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      border-radius: 0;
      z-index: 100;
    }

    .fullscreen-mode #videoElement,
    .fullscreen-mode #canvasElement {
      width: 100vw;
      height: 100vh;
      max-width: none;
      object-fit: cover;
    }

    .fullscreen-mode .recording-indicator {
      top: env(safe-area-inset-top, 15px);
      left: 15px;
    }

    .fullscreen-btn {
      position: fixed;
      bottom: 20px;
      right: 20px;
      z-index: 200;
      background: linear-gradient(135deg, #7c3aed, #00d4ff);
      border: none;
      color: #fff;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      font-size: 1.5rem;
      cursor: pointer;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
      display: none;
    }

    @media (max-width: 768px) {
      .fullscreen-btn {
        display: flex;
        align-items: center;
        justify-content: center;
      }
    }

    /* ========== SIGNS LIBRARY PANEL ========== */
    .signs-library-btn {
      position: fixed;
      bottom: 20px;
      left: 20px;
      z-index: 200;
      background: linear-gradient(135deg, #f59e0b, #fbbf24);
      border: none;
      color: #000;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      font-size: 1.5rem;
      cursor: pointer;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
    }

    .signs-library-panel {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(15, 12, 41, 0.98);
      backdrop-filter: blur(20px);
      border-top: 2px solid rgba(124, 58, 237, 0.5);
      border-radius: 20px 20px 0 0;
      padding: 20px;
      z-index: 300;
      transform: translateY(100%);
      transition: transform 0.3s ease;
      max-height: 70vh;
      overflow-y: auto;
    }

    .signs-library-panel.open {
      transform: translateY(0);
    }

    .signs-library-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
    }

    .signs-library-header h3 {
      color: #fbbf24;
      font-size: 1.1rem;
    }

    .close-library-btn {
      background: rgba(255, 255, 255, 0.1);
      border: none;
      color: #fff;
      width: 35px;
      height: 35px;
      border-radius: 50%;
      font-size: 1.2rem;
      cursor: pointer;
    }

    .signs-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
      gap: 10px;
    }

    .sign-card {
      background: rgba(255, 255, 255, 0.08);
      border: 2px solid rgba(255, 255, 255, 0.15);
      border-radius: 12px;
      padding: 15px 10px;
      text-align: center;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .sign-card:hover,
    .sign-card.active {
      background: linear-gradient(135deg, rgba(124, 58, 237, 0.3), rgba(0, 212, 255, 0.3));
      border-color: #7c3aed;
      transform: scale(1.02);
    }

    .sign-card .sign-name {
      font-size: 0.85rem;
      color: #fff;
      font-weight: 500;
    }

    .sign-card .sign-frames {
      font-size: 0.7rem;
      color: #a0aec0;
      margin-top: 5px;
    }

    .signs-empty {
      text-align: center;
      color: #a0aec0;
      padding: 30px;
    }

    /* ========== FUN MODE ========== */
    .mode-toggle {
      margin-bottom: 15px;
      display: flex;
      gap: 10px;
      justify-content: center;
    }

    .mode-btn {
      background: rgba(255, 255, 255, 0.1);
      border: 2px solid rgba(255, 255, 255, 0.3);
      color: #fff;
      padding: 12px 25px;
      border-radius: 25px;
      cursor: pointer;
      font-size: 0.95rem;
      font-weight: 500;
      transition: all 0.3s ease;
    }

    .mode-btn:hover {
      background: rgba(255, 255, 255, 0.2);
    }

    .mode-btn.active {
      background: linear-gradient(135deg, #f472b6, #fbbf24);
      border-color: transparent;
      color: #000;
    }

    .fun-mode-panel {
      display: none;
      background: rgba(255, 255, 255, 0.08);
      backdrop-filter: blur(20px);
      border: 1px solid rgba(255, 255, 255, 0.15);
      border-radius: 20px;
      padding: 25px;
      width: 100%;
      max-width: 600px;
      margin-bottom: 20px;
    }

    .fun-mode-panel.active {
      display: block;
    }

    .fun-mode-panel h2 {
      text-align: center;
      font-size: 1.2rem;
      color: #fbbf24;
      margin-bottom: 20px;
    }

    .detected-gesture {
      text-align: center;
      padding: 20px;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 15px;
      margin-bottom: 20px;
    }

    .gesture-emoji {
      font-size: 5rem;
      line-height: 1;
      animation: bounce 0.5s ease;
    }

    @keyframes bounce {

      0%,
      100% {
        transform: scale(1);
      }

      50% {
        transform: scale(1.1);
      }
    }

    .gesture-name-display {
      font-size: 1.5rem;
      font-weight: 700;
      margin-top: 10px;
      background: linear-gradient(90deg, #f472b6, #fbbf24);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .gesture-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
      gap: 10px;
    }

    .gesture-item {
      background: rgba(255, 255, 255, 0.05);
      border: 2px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      padding: 12px 8px;
      text-align: center;
      transition: all 0.3s ease;
    }

    .gesture-item.detected {
      background: linear-gradient(135deg, rgba(16, 185, 129, 0.3), rgba(0, 212, 255, 0.3));
      border-color: #10b981;
      transform: scale(1.05);
    }

    .gesture-item .emoji {
      font-size: 1.8rem;
    }

    .gesture-item .name {
      font-size: 0.7rem;
      color: #a0aec0;
      margin-top: 5px;
    }

    .validation-mode {
      display: block;
    }

    .validation-mode.hidden {
      display: none;
    }

    @media (max-width: 480px) {
      .fun-mode-panel {
        padding: 15px;
      }

      .gesture-emoji {
        font-size: 4rem;
      }

      .gesture-grid {
        grid-template-columns: repeat(4, 1fr);
        gap: 8px;
      }

      .gesture-item {
        padding: 8px 4px;
      }

      .gesture-item .emoji {
        font-size: 1.5rem;
      }

      .gesture-item .name {
        font-size: 0.6rem;
      }
    }
  </style>
</head>

<body>
  <h1>üéØ Gesture Validation</h1>
  <p class="subtitle">Record your gesture, compare with DTW for accurate matching</p>

  <!-- Mode Toggle -->
  <div class="mode-toggle">
    <button class="mode-btn active" id="validationModeBtn">üìä Validation Mode</button>
    <button class="mode-btn" id="funModeBtn">üéâ Fun Mode</button>
  </div>

  <!-- Fun Mode Panel -->
  <div class="fun-mode-panel" id="funModePanel">
    <h2>üñêÔ∏è Show Your Hand Signs!</h2>
    <div class="detected-gesture">
      <div class="gesture-emoji" id="funGestureEmoji">üëã</div>
      <div class="gesture-name-display" id="funGestureName">Waiting...</div>
    </div>
    <div class="gesture-grid" id="gestureGrid">
      <div class="gesture-item" data-gesture="thumbs_up">
        <div class="emoji">üëç</div>
        <div class="name">Thumbs Up</div>
      </div>
      <div class="gesture-item" data-gesture="thumbs_down">
        <div class="emoji">üëé</div>
        <div class="name">Thumbs Down</div>
      </div>
      <div class="gesture-item" data-gesture="peace">
        <div class="emoji">‚úåÔ∏è</div>
        <div class="name">Peace</div>
      </div>
      <div class="gesture-item" data-gesture="fist">
        <div class="emoji">‚úä</div>
        <div class="name">Fist</div>
      </div>
      <div class="gesture-item" data-gesture="open_palm">
        <div class="emoji">üñêÔ∏è</div>
        <div class="name">Open Palm</div>
      </div>
      <div class="gesture-item" data-gesture="pointing">
        <div class="emoji">‚òùÔ∏è</div>
        <div class="name">Pointing</div>
      </div>
      <div class="gesture-item" data-gesture="ok">
        <div class="emoji">üëå</div>
        <div class="name">OK Sign</div>
      </div>
      <div class="gesture-item" data-gesture="rock">
        <div class="emoji">ü§ò</div>
        <div class="name">Rock</div>
      </div>
      <div class="gesture-item" data-gesture="love">
        <div class="emoji">ü§ü</div>
        <div class="name">Love You</div>
      </div>
      <div class="gesture-item" data-gesture="call">
        <div class="emoji">ü§ô</div>
        <div class="name">Call Me</div>
      </div>
      <div class="gesture-item" data-gesture="three">
        <div class="emoji">üññ</div>
        <div class="name">Vulcan</div>
      </div>
      <div class="gesture-item" data-gesture="pinch">
        <div class="emoji">ü§è</div>
        <div class="name">Pinch</div>
      </div>
    </div>
  </div>

  <!-- Validation Mode Content -->
  <div class="validation-mode" id="validationMode">

    <!-- File Upload Section -->
    <div class="upload-section">
      <label class="upload-btn">
        üìÅ Load Reference Gesture
        <input type="file" id="fileInput" accept=".json" />
      </label>
      <div class="gesture-info">
        Loaded: <span class="gesture-name" id="loadedGestureName">None</span>
        <span id="frameCount"></span>
      </div>
    </div>

    <!-- Cloud Storage Section -->
    <div class="upload-section" id="cloudSection">
      <button class="upload-btn" id="uploadCloudBtn" disabled
        style="background: linear-gradient(135deg, #10b981, #00d4ff);">
        ‚òÅÔ∏è Upload to Cloud
      </button>
      <select id="cloudGestureSelect" class="upload-btn"
        style="background: linear-gradient(135deg, #f59e0b, #fbbf24); color: #000; padding: 12px 20px;">
        <option value="">üì• Load from Cloud...</option>
      </select>
      <div class="gesture-info">
        <span id="cloudStatus" style="color: #a0aec0;">‚òÅÔ∏è Connecting...</span>
      </div>
    </div>

    <div class="main-content">
      <!-- Live Camera Section -->
      <div class="video-section">
        <div class="section-label">üìπ Your Camera</div>
        <div class="container" id="cameraContainer">
          <video id="videoElement" width="560" height="420" autoplay playsinline></video>
          <canvas id="canvasElement" width="560" height="420"></canvas>
          <div class="recording-indicator" id="recordingIndicator">
            <div class="recording-dot"></div>
            <span>Recording... <span id="recordingFrames">0</span> frames</span>
          </div>
        </div>
        <div class="controls">
          <button class="record-btn" id="recordBtn" disabled>
            üî¥ Start Recording
          </button>
          <button class="play-btn active" id="toggleLandmarks">üëÅ Show Landmarks</button>
        </div>
        <div class="status-section">
          <div class="status-item fps">
            <div class="label">FPS</div>
            <div class="value" id="fpsValue">--</div>
          </div>
          <div class="status-item status">
            <div class="label">Status</div>
            <div class="value loading" id="statusValue">Loading...</div>
          </div>
        </div>
      </div>

      <!-- Reference Section -->
      <div class="reference-section">
        <div class="section-label">üé¨ Reference Gesture</div>
        <div class="reference-container">
          <canvas id="referenceCanvas" width="280" height="210"></canvas>
        </div>
        <div class="playback-controls">
          <button class="play-btn" id="playRefBtn" disabled>‚ñ∂ Play</button>
          <button class="play-btn" id="pauseRefBtn" disabled>‚è∏ Pause</button>
        </div>
        <div class="status-section">
          <div class="status-item frames">
            <div class="label">Frame</div>
            <div class="value"><span id="currentFrame">0</span>/<span id="totalFrames">0</span></div>
          </div>
        </div>
      </div>

      <!-- Results Panel -->
      <div class="results-panel">
        <h2>üìä Analysis Results</h2>

        <div class="score-display">
          <div class="score-value waiting" id="scoreValue">--%</div>
          <div class="score-label">DTW Similarity Score</div>
          <div class="result-badge" id="resultBadge" style="display: none;">Perfect! ‚úÖ</div>
        </div>

        <div class="feedback-section">
          <div class="feedback-title">Detailed Feedback</div>
          <ul class="feedback-list" id="feedbackList">
            <li class="feedback-item success">
              <span class="feedback-icon">üìã</span>
              <span>Load a gesture and record yours to get feedback</span>
            </li>
          </ul>
        </div>
      </div>
    </div>

    <div class="instructions">
      <h3>How It Works</h3>
      <div class="steps">
        <div class="step">
          <div class="step-number">1</div>
          <div class="step-text"><strong>Load</strong> a reference gesture JSON file (from pose_extraction.py)</div>
        </div>
        <div class="step">
          <div class="step-number">2</div>
          <div class="step-text"><strong>Click Start Recording</strong> and perform the gesture</div>
        </div>
        <div class="step">
          <div class="step-number">3</div>
          <div class="step-text"><strong>Click Stop</strong> when done - DTW ignores timing differences!</div>
        </div>
        <div class="step">
          <div class="step-number">4</div>
          <div class="step-text"><strong>Get feedback</strong> on what's correct and what needs work</div>
        </div>
      </div>
    </div>

  </div> <!-- End validation-mode -->

  <!-- Fullscreen Button (Mobile) -->
  <button class="fullscreen-btn" id="fullscreenBtn">‚õ∂</button>

  <!-- Signs Library Button -->
  <button class="signs-library-btn" id="signsLibraryBtn">üìö</button>

  <!-- Signs Library Panel -->
  <div class="signs-library-panel" id="signsLibraryPanel">
    <div class="signs-library-header">
      <h3>üìö Signs Library</h3>
      <button class="close-library-btn" id="closeLibraryBtn">‚úï</button>
    </div>
    <div class="signs-grid" id="signsGrid">
      <div class="signs-empty">Loading signs from cloud...</div>
    </div>
  </div>


  <!-- Supabase Client -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

  <!-- MediaPipe Scripts -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/holistic/holistic.js" crossorigin="anonymous"></script>

  <script>
    // ========== DOM ELEMENTS ==========
    const videoElement = document.getElementById('videoElement');
    const canvasElement = document.getElementById('canvasElement');
    const canvasCtx = canvasElement.getContext('2d');
    const referenceCanvas = document.getElementById('referenceCanvas');
    const referenceCtx = referenceCanvas.getContext('2d');
    const cameraContainer = document.getElementById('cameraContainer');
    const recordingIndicator = document.getElementById('recordingIndicator');

    const fileInput = document.getElementById('fileInput');
    const loadedGestureName = document.getElementById('loadedGestureName');
    const frameCountSpan = document.getElementById('frameCount');

    const recordBtn = document.getElementById('recordBtn');
    const recordingFramesEl = document.getElementById('recordingFrames');

    const playRefBtn = document.getElementById('playRefBtn');
    const pauseRefBtn = document.getElementById('pauseRefBtn');
    const currentFrameEl = document.getElementById('currentFrame');
    const totalFramesEl = document.getElementById('totalFrames');

    const scoreValue = document.getElementById('scoreValue');
    const resultBadge = document.getElementById('resultBadge');
    const feedbackList = document.getElementById('feedbackList');

    const fpsValueEl = document.getElementById('fpsValue');
    const statusValueEl = document.getElementById('statusValue');

    // ========== STATE ==========
    let referenceGesture = null;
    let recordedGesture = [];
    let isRecording = false;
    let refFrameIndex = 0;
    let refPlayInterval = null;
    let showLandmarks = true;

    // ========== SUPABASE CONFIGURATION ==========
    const SUPABASE_URL = 'https://rduqgaayrrsirkkiyaxw.supabase.co';
    const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InJkdXFnYWF5cnJzaXJra2l5YXh3Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NzA1NzM5MTksImV4cCI6MjA4NjE0OTkxOX0.a4_fTKl-OmDc00aSmOtEcULHh31gZCCXlHlLw1xASVk';

    // Cloud UI Elements
    const uploadCloudBtn = document.getElementById('uploadCloudBtn');
    const cloudGestureSelect = document.getElementById('cloudGestureSelect');
    const cloudStatus = document.getElementById('cloudStatus');

    // Supabase Client
    let supabaseClient = null;
    let gesturesDict = {}; // Cache for loaded gestures

    // Initialize Supabase
    async function initSupabase() {
      try {
        if (SUPABASE_URL === 'YOUR_SUPABASE_URL') {
          cloudStatus.innerHTML = '‚ö†Ô∏è <a href="#" onclick="alert(\'Add your Supabase credentials in the script\'); return false;" style="color: #f59e0b;">Configure Supabase</a>';
          console.warn('Supabase not configured. Add your SUPABASE_URL and SUPABASE_ANON_KEY.');
          return;
        }

        supabaseClient = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
        cloudStatus.textContent = '‚òÅÔ∏è Connected';
        cloudStatus.style.color = '#10b981';
        console.log('Supabase connected successfully!');

        // Load available gestures
        await refreshCloudGestures();
      } catch (error) {
        cloudStatus.textContent = '‚ùå Connection failed';
        cloudStatus.style.color = '#ef4444';
        console.error('Supabase init error:', error);
      }
    }

    // Fetch all gestures from Supabase
    async function refreshCloudGestures() {
      if (!supabaseClient) return;

      try {
        const { data, error } = await supabaseClient
          .from('gestures')
          .select('name, frame_count')
          .order('name');

        if (error) throw error;

        // Update dropdown
        cloudGestureSelect.innerHTML = '<option value="">üì• Load from Cloud...</option>';
        data.forEach(gesture => {
          const option = document.createElement('option');
          option.value = gesture.name;
          option.textContent = `${gesture.name} (${gesture.frame_count} frames)`;
          cloudGestureSelect.appendChild(option);
        });

        console.log(`Loaded ${data.length} gestures from cloud`);
      } catch (error) {
        console.error('Error fetching gestures:', error);
      }
    }

    // Upload gesture to Supabase
    async function uploadGestureToSupabase(name, data) {
      if (!supabaseClient) {
        alert('Supabase not connected. Please configure your credentials.');
        return false;
      }

      try {
        cloudStatus.textContent = '‚è≥ Uploading...';
        cloudStatus.style.color = '#f59e0b';

        const { error } = await supabaseClient
          .from('gestures')
          .upsert({
            name: name,
            data: data,
            frame_count: data.length,
            updated_at: new Date().toISOString()
          }, { onConflict: 'name' });

        if (error) throw error;

        cloudStatus.textContent = '‚úÖ Uploaded!';
        cloudStatus.style.color = '#10b981';
        setTimeout(() => {
          cloudStatus.textContent = '‚òÅÔ∏è Connected';
        }, 2000);

        await refreshCloudGestures();
        return true;
      } catch (error) {
        cloudStatus.textContent = '‚ùå Upload failed';
        cloudStatus.style.color = '#ef4444';
        console.error('Upload error:', error);
        alert('Upload failed: ' + error.message);
        return false;
      }
    }

    // Load gesture from Supabase
    async function loadGestureFromSupabase(name) {
      if (!supabaseClient) return null;

      try {
        cloudStatus.textContent = '‚è≥ Loading...';
        cloudStatus.style.color = '#f59e0b';

        const { data, error } = await supabaseClient
          .from('gestures')
          .select('data')
          .eq('name', name)
          .single();

        if (error) throw error;

        cloudStatus.textContent = '‚òÅÔ∏è Connected';
        cloudStatus.style.color = '#10b981';

        // Cache the gesture
        gesturesDict[name] = data.data;
        return data.data;
      } catch (error) {
        cloudStatus.textContent = '‚ùå Load failed';
        cloudStatus.style.color = '#ef4444';
        console.error('Load error:', error);
        return null;
      }
    }

    // Get all gestures as dictionary
    async function getGesturesAsDictionary() {
      if (!supabaseClient) return {};

      try {
        const { data, error } = await supabaseClient
          .from('gestures')
          .select('name, data');

        if (error) throw error;

        return data.reduce((dict, gesture) => {
          dict[gesture.name] = gesture.data;
          return dict;
        }, {});
      } catch (error) {
        console.error('Error fetching gestures dictionary:', error);
        return {};
      }
    }

    // Cloud UI Event Handlers
    uploadCloudBtn.addEventListener('click', async () => {
      if (!referenceGesture || !referenceGesture.length) {
        alert('No gesture loaded to upload. Load a JSON file first.');
        return;
      }

      const currentName = loadedGestureName.textContent;
      const gestureName = prompt('Enter gesture name:', currentName !== 'None' ? currentName : '');

      if (gestureName && gestureName.trim()) {
        await uploadGestureToSupabase(gestureName.trim(), referenceGesture);
      }
    });

    cloudGestureSelect.addEventListener('change', async (e) => {
      const selectedName = e.target.value;
      if (!selectedName) return;

      const gestureData = await loadGestureFromSupabase(selectedName);
      if (gestureData) {
        referenceGesture = gestureData;
        loadedGestureName.textContent = selectedName;
        frameCountSpan.textContent = ` (${gestureData.length} frames)`;
        totalFramesEl.textContent = gestureData.length;
        recordBtn.disabled = false;
        playRefBtn.disabled = false;
        pauseRefBtn.disabled = false;
        uploadCloudBtn.disabled = false;
        refFrameIndex = 0;
        drawReferenceFrame(0);
        console.log(`Loaded "${selectedName}" from cloud: ${gestureData.length} frames`);
      }

      // Reset dropdown
      cloudGestureSelect.value = '';
    });

    // Initialize Supabase on page load
    initSupabase();

    // ========== FULLSCREEN MODE ==========
    const fullscreenBtn = document.getElementById('fullscreenBtn');
    let isFullscreen = false;

    fullscreenBtn.addEventListener('click', () => {
      isFullscreen = !isFullscreen;
      document.documentElement.classList.toggle('fullscreen-mode', isFullscreen);
      fullscreenBtn.textContent = isFullscreen ? '‚úï' : '‚õ∂';
    });

    // ========== SIGNS LIBRARY ==========
    const signsLibraryBtn = document.getElementById('signsLibraryBtn');
    const signsLibraryPanel = document.getElementById('signsLibraryPanel');
    const closeLibraryBtn = document.getElementById('closeLibraryBtn');
    const signsGrid = document.getElementById('signsGrid');

    signsLibraryBtn.addEventListener('click', () => {
      signsLibraryPanel.classList.add('open');
      loadSignsLibrary();
    });

    closeLibraryBtn.addEventListener('click', () => {
      signsLibraryPanel.classList.remove('open');
    });

    // Load all signs from Supabase
    async function loadSignsLibrary() {
      if (!supabaseClient) {
        signsGrid.innerHTML = '<div class="signs-empty">‚ö†Ô∏è Connect to Supabase first</div>';
        return;
      }

      try {
        const { data, error } = await supabaseClient
          .from('gestures')
          .select('name, frame_count')
          .order('name');

        if (error) throw error;

        if (data.length === 0) {
          signsGrid.innerHTML = '<div class="signs-empty">No signs saved yet.<br>Upload your first sign!</div>';
          return;
        }

        signsGrid.innerHTML = data.map(sign => `
          <div class="sign-card" data-sign="${sign.name}">
            <div class="sign-name">${sign.name}</div>
            <div class="sign-frames">${sign.frame_count} frames</div>
          </div>
        `).join('');

        // Add click handlers
        signsGrid.querySelectorAll('.sign-card').forEach(card => {
          card.addEventListener('click', async () => {
            const signName = card.dataset.sign;
            const gestureData = await loadGestureFromSupabase(signName);
            if (gestureData) {
              referenceGesture = gestureData;
              loadedGestureName.textContent = signName;
              frameCountSpan.textContent = ` (${gestureData.length} frames)`;
              totalFramesEl.textContent = gestureData.length;
              recordBtn.disabled = false;
              playRefBtn.disabled = false;
              pauseRefBtn.disabled = false;
              uploadCloudBtn.disabled = false;
              refFrameIndex = 0;
              drawReferenceFrame(0);
              signsLibraryPanel.classList.remove('open');
            }
          });
        });
      } catch (error) {
        console.error('Error loading signs library:', error);
        signsGrid.innerHTML = '<div class="signs-empty">‚ùå Error loading signs</div>';
      }
    }

    // ========== PUSH NEW JSON TO SUPABASE ==========
    // Function to push any JSON data to Supabase
    async function pushNewJsonToSupabase(name, jsonData) {
      if (!supabaseClient) {
        console.error('Supabase not connected');
        return { success: false, error: 'Supabase not connected' };
      }

      try {
        const { data, error } = await supabaseClient
          .from('gestures')
          .upsert({
            name: name,
            data: jsonData,
            frame_count: Array.isArray(jsonData) ? jsonData.length : 1,
            updated_at: new Date().toISOString()
          }, { onConflict: 'name' });

        if (error) throw error;

        console.log(`Successfully pushed "${name}" to Supabase`);
        await refreshCloudGestures();
        return { success: true };
      } catch (error) {
        console.error('Error pushing to Supabase:', error);
        return { success: false, error: error.message };
      }
    }

    // Expose function globally for console access
    window.pushNewJsonToSupabase = pushNewJsonToSupabase;
    window.loadSignsLibrary = loadSignsLibrary;
    window.getGesturesAsDictionary = getGesturesAsDictionary;


    const toggleLandmarksBtn = document.getElementById('toggleLandmarks');

    // Toggle landmarks visibility
    toggleLandmarksBtn.addEventListener('click', () => {
      showLandmarks = !showLandmarks;
      toggleLandmarksBtn.classList.toggle('active', showLandmarks);
      toggleLandmarksBtn.textContent = showLandmarks ? 'üëÅ Show Landmarks' : 'üëÅ Hide Landmarks';
    });

    // ========== FUN MODE ==========
    const validationModeBtn = document.getElementById('validationModeBtn');
    const funModeBtn = document.getElementById('funModeBtn');
    const funModePanel = document.getElementById('funModePanel');
    const validationMode = document.getElementById('validationMode');
    const funGestureEmoji = document.getElementById('funGestureEmoji');
    const funGestureName = document.getElementById('funGestureName');
    const gestureGrid = document.getElementById('gestureGrid');

    let isFunMode = false;

    const GESTURES = {
      thumbs_up: { emoji: 'üëç', name: 'Thumbs Up' },
      thumbs_down: { emoji: 'üëé', name: 'Thumbs Down' },
      peace: { emoji: '‚úåÔ∏è', name: 'Peace' },
      fist: { emoji: '‚úä', name: 'Fist' },
      open_palm: { emoji: 'üñêÔ∏è', name: 'Open Palm' },
      pointing: { emoji: '‚òùÔ∏è', name: 'Pointing' },
      ok: { emoji: 'üëå', name: 'OK Sign' },
      rock: { emoji: 'ü§ò', name: 'Rock' },
      love: { emoji: 'ü§ü', name: 'Love You' },
      call: { emoji: 'ü§ô', name: 'Call Me' },
      three: { emoji: 'üññ', name: 'Vulcan' },
      pinch: { emoji: 'ü§è', name: 'Pinch' },
      none: { emoji: 'üëã', name: 'Show a gesture!' }
    };

    validationModeBtn.addEventListener('click', () => {
      isFunMode = false;
      validationModeBtn.classList.add('active');
      funModeBtn.classList.remove('active');
      funModePanel.classList.remove('active');
      validationMode.classList.remove('hidden');
    });

    funModeBtn.addEventListener('click', () => {
      isFunMode = true;
      funModeBtn.classList.add('active');
      validationModeBtn.classList.remove('active');
      funModePanel.classList.add('active');
      validationMode.classList.add('hidden');
    });

    // Gesture Recognition Functions
    function distance(p1, p2) {
      return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
    }

    function isFingerExtended(landmarks, fingerBase, fingerTip, wrist) {
      const baseToTip = distance(landmarks[fingerBase], landmarks[fingerTip]);
      const wristToBase = distance(landmarks[wrist], landmarks[fingerBase]);
      return baseToTip > wristToBase * 0.5;
    }

    function getFingerStates(landmarks) {
      const wrist = 0;
      // Thumb - special case (compare to index MCP)
      const thumbExtended = landmarks[4].x < landmarks[3].x; // For right hand

      return {
        thumb: distance(landmarks[4], landmarks[2]) > distance(landmarks[3], landmarks[2]) * 0.8,
        index: isFingerExtended(landmarks, 5, 8, wrist),
        middle: isFingerExtended(landmarks, 9, 12, wrist),
        ring: isFingerExtended(landmarks, 13, 16, wrist),
        pinky: isFingerExtended(landmarks, 17, 20, wrist)
      };
    }

    function recognizeGesture(landmarks) {
      if (!landmarks || landmarks.length < 21) return 'none';

      const fingers = getFingerStates(landmarks);
      const extendedCount = Object.values(fingers).filter(v => v).length;

      const thumbTip = landmarks[4];
      const indexTip = landmarks[8];
      const middleTip = landmarks[12];
      const wrist = landmarks[0];

      // Pinch - thumb and index close together
      if (distance(thumbTip, indexTip) < 0.05) {
        if (!fingers.middle && !fingers.ring && !fingers.pinky) {
          return 'pinch';
        }
        return 'ok';
      }

      // Thumbs up - only thumb extended, thumb pointing up
      if (fingers.thumb && !fingers.index && !fingers.middle && !fingers.ring && !fingers.pinky) {
        if (thumbTip.y < landmarks[2].y) {
          return 'thumbs_up';
        } else {
          return 'thumbs_down';
        }
      }

      // Fist - no fingers extended
      if (extendedCount === 0) {
        return 'fist';
      }

      // Open palm - all fingers extended
      if (extendedCount === 5) {
        return 'open_palm';
      }

      // Pointing - only index extended
      if (fingers.index && !fingers.middle && !fingers.ring && !fingers.pinky) {
        return 'pointing';
      }

      // Peace - index and middle extended
      if (fingers.index && fingers.middle && !fingers.ring && !fingers.pinky) {
        return 'peace';
      }

      // Rock - index and pinky extended
      if (fingers.index && !fingers.middle && !fingers.ring && fingers.pinky) {
        return 'rock';
      }

      // Love you (ASL) - thumb, index, pinky extended
      if (fingers.thumb && fingers.index && !fingers.middle && !fingers.ring && fingers.pinky) {
        return 'love';
      }

      // Call me - thumb and pinky extended
      if (fingers.thumb && !fingers.index && !fingers.middle && !fingers.ring && fingers.pinky) {
        return 'call';
      }

      // Vulcan/Three - index, middle, ring extended with gap
      if (fingers.index && fingers.middle && fingers.ring && !fingers.pinky) {
        return 'three';
      }

      return 'none';
    }

    function updateFunModeDisplay(gesture) {
      const gestureData = GESTURES[gesture] || GESTURES.none;
      funGestureEmoji.textContent = gestureData.emoji;
      funGestureName.textContent = gestureData.name;

      // Update grid highlighting
      document.querySelectorAll('.gesture-item').forEach(item => {
        item.classList.remove('detected');
        if (item.dataset.gesture === gesture) {
          item.classList.add('detected');
        }
      });
    }

    let frameCount = 0;
    let lastTime = performance.now();

    // Landmark names for feedback
    const FINGER_NAMES = ['Wrist', 'Thumb CMC', 'Thumb MCP', 'Thumb IP', 'Thumb Tip',
      'Index MCP', 'Index PIP', 'Index DIP', 'Index Tip',
      'Middle MCP', 'Middle PIP', 'Middle DIP', 'Middle Tip',
      'Ring MCP', 'Ring PIP', 'Ring DIP', 'Ring Tip',
      'Pinky MCP', 'Pinky PIP', 'Pinky DIP', 'Pinky Tip'];

    const FINGER_GROUPS = {
      'Thumb': [1, 2, 3, 4],
      'Index': [5, 6, 7, 8],
      'Middle': [9, 10, 11, 12],
      'Ring': [13, 14, 15, 16],
      'Pinky': [17, 18, 19, 20]
    };

    // ========== FILE LOADING ==========
    fileInput.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = (event) => {
        try {
          referenceGesture = JSON.parse(event.target.result);
          const gestureName = file.name.replace('.json', '');
          loadedGestureName.textContent = gestureName;
          frameCountSpan.textContent = ` (${referenceGesture.length} frames)`;
          totalFramesEl.textContent = referenceGesture.length;

          recordBtn.disabled = false;
          playRefBtn.disabled = false;
          pauseRefBtn.disabled = false;
          uploadCloudBtn.disabled = false;

          drawReferenceFrame(0);
          updateFeedback([{
            type: 'success',
            icon: '‚úÖ',
            text: `Loaded "${gestureName}" - Ready to record!`
          }]);
        } catch (err) {
          console.error('Error parsing JSON:', err);
          updateFeedback([{
            type: 'error',
            icon: '‚ùå',
            text: 'Error loading file'
          }]);
        }
      };
      reader.readAsText(file);
    });

    // ========== RECORDING ==========
    recordBtn.addEventListener('click', toggleRecording);

    function toggleRecording(e) {
      e.preventDefault();
      if (!referenceGesture) return;

      if (isRecording) {
        // Stop recording
        isRecording = false;
        recordBtn.textContent = 'üî¥ Start Recording';
        recordBtn.classList.remove('recording');
        cameraContainer.classList.remove('recording');
        recordingIndicator.classList.remove('active');

        if (recordedGesture.length < 5) {
          updateFeedback([{
            type: 'error',
            icon: '‚ö†Ô∏è',
            text: 'Recording too short. Try again!'
          }]);
          return;
        }

        // Analyze with DTW
        analyzeGesture();
      } else {
        // Start recording
        isRecording = true;
        recordedGesture = [];
        recordBtn.textContent = '‚èπ Stop Recording';
        recordBtn.classList.add('recording');
        cameraContainer.classList.add('recording');
        recordingIndicator.classList.add('active');
        recordingFramesEl.textContent = '0';

        scoreValue.textContent = '--%';
        scoreValue.className = 'score-value waiting';
        resultBadge.style.display = 'none';
        updateFeedback([{
          type: 'success',
          icon: 'üé¨',
          text: 'Recording... perform the gesture now!'
        }]);
      }
    }

    // ========== DTW ALGORITHM ==========
    function computeDTW(seq1, seq2) {
      const n = seq1.length;
      const m = seq2.length;

      // Create distance matrix
      const dtw = Array(n + 1).fill(null).map(() => Array(m + 1).fill(Infinity));
      dtw[0][0] = 0;

      for (let i = 1; i <= n; i++) {
        for (let j = 1; j <= m; j++) {
          const cost = landmarkDistance(seq1[i - 1], seq2[j - 1]);
          dtw[i][j] = cost + Math.min(
            dtw[i - 1][j],     // insertion
            dtw[i][j - 1],     // deletion
            dtw[i - 1][j - 1]  // match
          );
        }
      }

      return dtw[n][m] / Math.max(n, m); // Normalize by path length
    }

    function landmarkDistance(frame1, frame2) {
      let totalDist = 0;
      let count = 0;

      // Compare hands
      ['left_hand', 'right_hand'].forEach(handKey => {
        const hand1 = frame1[handKey];
        const hand2 = frame2[handKey];

        if (hand1 && hand1.length > 0 && hand2 && hand2.length > 0) {
          // Normalize relative to wrist
          const wrist1 = hand1[0];
          const wrist2 = hand2[0];

          for (let i = 0; i < Math.min(hand1.length, hand2.length); i++) {
            const p1 = { x: hand1[i].x - wrist1.x, y: hand1[i].y - wrist1.y };
            const p2 = { x: hand2[i].x - wrist2.x, y: hand2[i].y - wrist2.y };

            totalDist += Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
            count++;
          }
        }
      });

      return count > 0 ? totalDist / count : 1;
    }

    function analyzeGesture() {
      if (!referenceGesture || recordedGesture.length === 0) return;

      // Extract hand sequences
      const refSeq = referenceGesture.map(f => ({
        left_hand: f.left_hand,
        right_hand: f.right_hand
      }));

      const recSeq = recordedGesture.map(f => ({
        left_hand: f.left_hand,
        right_hand: f.right_hand
      }));

      // Compute DTW distance
      const dtwDistance = computeDTW(recSeq, refSeq);

      // Convert to similarity percentage (lower distance = higher similarity)
      // Typical good match has distance < 0.05, bad match > 0.15
      const similarity = Math.max(0, Math.min(100, 100 - (dtwDistance * 500)));

      // Update score display
      scoreValue.textContent = Math.round(similarity) + '%';
      scoreValue.className = 'score-value';

      // Generate detailed feedback
      const feedback = [];
      const fingerErrors = analyzeFingerErrors();

      if (similarity >= 90) {
        scoreValue.classList.add('excellent');
        resultBadge.textContent = 'Perfect! ‚úÖ';
        resultBadge.className = 'result-badge perfect';
        resultBadge.style.display = 'inline-block';
        feedback.push({
          type: 'success',
          icon: 'üéâ',
          text: 'Excellent match! Your gesture is accurate!'
        });
      } else if (similarity >= 70) {
        scoreValue.classList.add('good');
        resultBadge.textContent = 'Good! üëç';
        resultBadge.className = 'result-badge good';
        resultBadge.style.display = 'inline-block';
        feedback.push({
          type: 'success',
          icon: 'üëç',
          text: 'Good job! Minor adjustments needed.'
        });
      } else {
        scoreValue.classList.add('poor');
        resultBadge.textContent = 'Keep Practicing üí™';
        resultBadge.className = 'result-badge needs-work';
        resultBadge.style.display = 'inline-block';
        feedback.push({
          type: 'warning',
          icon: 'üí™',
          text: 'Needs more practice. Check the issues below.'
        });
      }

      // Add specific finger feedback
      fingerErrors.forEach(err => {
        feedback.push({
          type: err.severity,
          icon: err.icon,
          text: err.message
        });
      });

      // Add general tips
      if (fingerErrors.length === 0 && similarity < 90) {
        feedback.push({
          type: 'warning',
          icon: '‚è±Ô∏è',
          text: 'Try matching the movement speed and flow better'
        });
      }

      updateFeedback(feedback);
    }

    function analyzeFingerErrors() {
      const errors = [];
      if (!referenceGesture || recordedGesture.length === 0) return errors;

      // Sample middle frames for comparison
      const refMid = referenceGesture[Math.floor(referenceGesture.length / 2)];
      const recMid = recordedGesture[Math.floor(recordedGesture.length / 2)];

      // Analyze each hand
      ['left_hand', 'right_hand'].forEach((handKey, handIdx) => {
        const handName = handIdx === 0 ? 'Left' : 'Right';
        const refHand = refMid[handKey];
        const recHand = recMid[handKey];

        if (!refHand || refHand.length === 0) return;
        if (!recHand || recHand.length === 0) {
          errors.push({
            severity: 'error',
            icon: 'üñêÔ∏è',
            message: `${handName} hand not detected - make sure it's visible`
          });
          return;
        }

        // Normalize relative to wrist
        const refWrist = refHand[0];
        const recWrist = recHand[0];

        // Check each finger group
        Object.entries(FINGER_GROUPS).forEach(([fingerName, indices]) => {
          let fingerError = 0;
          indices.forEach(i => {
            if (refHand[i] && recHand[i]) {
              const refNorm = { x: refHand[i].x - refWrist.x, y: refHand[i].y - refWrist.y };
              const recNorm = { x: recHand[i].x - recWrist.x, y: recHand[i].y - recWrist.y };
              fingerError += Math.sqrt(Math.pow(refNorm.x - recNorm.x, 2) + Math.pow(refNorm.y - recNorm.y, 2));
            }
          });
          fingerError /= indices.length;

          // Check direction
          const tipIdx = indices[indices.length - 1];
          const baseIdx = indices[0];

          if (refHand[tipIdx] && recHand[tipIdx] && refHand[baseIdx] && recHand[baseIdx]) {
            const refTipY = refHand[tipIdx].y - refWrist.y;
            const recTipY = recHand[tipIdx].y - recWrist.y;

            if (fingerError > 0.08) {
              let direction = '';
              if (recTipY > refTipY + 0.03) {
                direction = 'too low';
              } else if (recTipY < refTipY - 0.03) {
                direction = 'too high';
              } else {
                const refTipX = refHand[tipIdx].x - refWrist.x;
                const recTipX = recHand[tipIdx].x - recWrist.x;
                if (recTipX > refTipX + 0.03) {
                  direction = 'too far right';
                } else if (recTipX < refTipX - 0.03) {
                  direction = 'too far left';
                }
              }

              if (direction) {
                errors.push({
                  severity: fingerError > 0.12 ? 'error' : 'warning',
                  icon: fingerError > 0.12 ? '‚ùå' : '‚ö†Ô∏è',
                  message: `${handName} ${fingerName} finger is ${direction}`
                });
              }
            }
          }
        });

        // Check if hand is extended vs curled (overall shape)
        const refSpread = calculateHandSpread(refHand);
        const recSpread = calculateHandSpread(recHand);

        if (Math.abs(refSpread - recSpread) > 0.1) {
          if (recSpread < refSpread) {
            errors.push({
              severity: 'warning',
              icon: '‚úä',
              message: `${handName} hand should be more open/spread`
            });
          } else {
            errors.push({
              severity: 'warning',
              icon: 'üñêÔ∏è',
              message: `${handName} hand should be more closed/curled`
            });
          }
        }
      });

      return errors;
    }

    function calculateHandSpread(hand) {
      if (!hand || hand.length < 21) return 0;

      // Calculate average distance from wrist to fingertips
      const tipIndices = [4, 8, 12, 16, 20];
      let totalDist = 0;

      tipIndices.forEach(i => {
        if (hand[i] && hand[0]) {
          totalDist += Math.sqrt(
            Math.pow(hand[i].x - hand[0].x, 2) +
            Math.pow(hand[i].y - hand[0].y, 2)
          );
        }
      });

      return totalDist / tipIndices.length;
    }

    function updateFeedback(items) {
      feedbackList.innerHTML = '';
      items.forEach(item => {
        const li = document.createElement('li');
        li.className = `feedback-item ${item.type}`;
        li.innerHTML = `
          <span class="feedback-icon">${item.icon}</span>
          <span>${item.text}</span>
        `;
        feedbackList.appendChild(li);
      });
    }

    // ========== REFERENCE PLAYBACK ==========
    playRefBtn.addEventListener('click', () => {
      if (!referenceGesture) return;
      playRefBtn.classList.add('active');
      pauseRefBtn.classList.remove('active');

      if (refPlayInterval) clearInterval(refPlayInterval);
      refPlayInterval = setInterval(() => {
        refFrameIndex = (refFrameIndex + 1) % referenceGesture.length;
        currentFrameEl.textContent = refFrameIndex + 1;
        drawReferenceFrame(refFrameIndex);
      }, 1000 / 30);
    });

    pauseRefBtn.addEventListener('click', () => {
      pauseRefBtn.classList.add('active');
      playRefBtn.classList.remove('active');
      if (refPlayInterval) {
        clearInterval(refPlayInterval);
        refPlayInterval = null;
      }
    });

    // ========== DRAWING ==========
    const POSE_COLORS = { TORSO: '#fbbf24', LEFT_ARM: '#10b981', RIGHT_ARM: '#3b82f6', LEFT_LEG: '#a855f7', RIGHT_LEG: '#ec4899' };
    const FINGER_COLORS = { WRIST: '#ff6b6b', THUMB: '#ffd93d', INDEX: '#6bcb77', MIDDLE: '#4d96ff', RING: '#c77dff', PINKY: '#ff6b9d' };

    const POSE_CONNECTIONS = [[11, 12], [11, 23], [12, 24], [23, 24], [11, 13], [13, 15], [15, 17], [15, 19], [15, 21], [12, 14], [14, 16], [16, 18], [16, 20], [16, 22], [23, 25], [25, 27], [27, 29], [27, 31], [24, 26], [26, 28], [28, 30], [28, 32]];
    const HAND_CONNECTIONS = [[0, 1], [1, 2], [2, 3], [3, 4], [0, 5], [5, 6], [6, 7], [7, 8], [0, 9], [9, 10], [10, 11], [11, 12], [0, 13], [13, 14], [14, 15], [15, 16], [0, 17], [17, 18], [18, 19], [19, 20], [5, 9], [9, 13], [13, 17]];

    function getPoseColor(i) {
      if ([11, 13, 15, 17, 19, 21].includes(i)) return POSE_COLORS.LEFT_ARM;
      if ([12, 14, 16, 18, 20, 22].includes(i)) return POSE_COLORS.RIGHT_ARM;
      if ([23, 25, 27, 29, 31].includes(i)) return POSE_COLORS.LEFT_LEG;
      if ([24, 26, 28, 30, 32].includes(i)) return POSE_COLORS.RIGHT_LEG;
      return POSE_COLORS.TORSO;
    }

    function getHandColor(i) {
      if (i === 0) return FINGER_COLORS.WRIST;
      if (i <= 4) return FINGER_COLORS.THUMB;
      if (i <= 8) return FINGER_COLORS.INDEX;
      if (i <= 12) return FINGER_COLORS.MIDDLE;
      if (i <= 16) return FINGER_COLORS.RING;
      return FINGER_COLORS.PINKY;
    }

    function drawLandmark(ctx, x, y, r, color) {
      ctx.beginPath();
      ctx.arc(x, y, r, 0, 2 * Math.PI);
      ctx.fillStyle = color;
      ctx.fill();
    }

    function drawConnection(ctx, x1, y1, x2, y2, color, w) {
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.strokeStyle = color;
      ctx.lineWidth = w;
      ctx.stroke();
    }

    function drawReferenceFrame(idx) {
      if (!referenceGesture || !referenceGesture[idx]) return;
      const frame = referenceGesture[idx];
      const w = referenceCanvas.width, h = referenceCanvas.height;

      referenceCtx.fillStyle = 'rgba(15, 12, 41, 0.95)';
      referenceCtx.fillRect(0, 0, w, h);

      // Draw pose
      if (frame.pose) {
        POSE_CONNECTIONS.forEach(([s, e]) => {
          const p1 = frame.pose[s], p2 = frame.pose[e];
          if (p1 && p2 && (p1.vis || 0) > 0.3 && (p2.vis || 0) > 0.3) {
            drawConnection(referenceCtx, p1.x * w, p1.y * h, p2.x * w, p2.y * h, getPoseColor(s), 2);
          }
        });
        frame.pose.forEach((lm, i) => {
          if (i > 10 && (lm.vis || 0) > 0.3) drawLandmark(referenceCtx, lm.x * w, lm.y * h, 3, getPoseColor(i));
        });
      }

      // Draw hands
      [frame.left_hand, frame.right_hand].forEach(hand => {
        if (hand && hand.length > 0) {
          HAND_CONNECTIONS.forEach(([s, e]) => {
            const p1 = hand[s], p2 = hand[e];
            if (p1 && p2) drawConnection(referenceCtx, p1.x * w, p1.y * h, p2.x * w, p2.y * h, getHandColor(s), 2);
          });
          hand.forEach((lm, i) => drawLandmark(referenceCtx, lm.x * w, lm.y * h, 2, getHandColor(i)));
        }
      });
    }

    // ========== MEDIAPIPE ==========
    function onResults(results) {
      frameCount++;
      const now = performance.now();
      if (now - lastTime >= 1000) {
        fpsValueEl.textContent = frameCount;
        frameCount = 0;
        lastTime = now;
      }

      const w = canvasElement.width, h = canvasElement.height;
      canvasCtx.save();
      canvasCtx.clearRect(0, 0, w, h);
      canvasCtx.drawImage(results.image, 0, 0, w, h);

      // Record frame if recording
      if (isRecording) {
        const frameData = {
          left_hand: results.leftHandLandmarks ? results.leftHandLandmarks.map(lm => ({ x: lm.x, y: lm.y, z: lm.z })) : [],
          right_hand: results.rightHandLandmarks ? results.rightHandLandmarks.map(lm => ({ x: lm.x, y: lm.y, z: lm.z })) : [],
          pose: results.poseLandmarks ? results.poseLandmarks.map(lm => ({ x: lm.x, y: lm.y, z: lm.z, vis: lm.visibility })) : []
        };
        recordedGesture.push(frameData);
        recordingFramesEl.textContent = recordedGesture.length;
      }

      // Draw landmarks only if enabled
      if (showLandmarks) {
        // Draw pose
        if (results.poseLandmarks) {
          POSE_CONNECTIONS.forEach(([s, e]) => {
            const p1 = results.poseLandmarks[s], p2 = results.poseLandmarks[e];
            if (p1 && p2 && p1.visibility > 0.5 && p2.visibility > 0.5) {
              drawConnection(canvasCtx, p1.x * w, p1.y * h, p2.x * w, p2.y * h, getPoseColor(s), 3);
            }
          });
          results.poseLandmarks.forEach((lm, i) => {
            if (i > 10 && lm.visibility > 0.5) drawLandmark(canvasCtx, lm.x * w, lm.y * h, 5, getPoseColor(i));
          });
        }

        // Draw hands
        [results.leftHandLandmarks, results.rightHandLandmarks].forEach(hand => {
          if (hand) {
            HAND_CONNECTIONS.forEach(([s, e]) => {
              const p1 = hand[s], p2 = hand[e];
              drawConnection(canvasCtx, p1.x * w, p1.y * h, p2.x * w, p2.y * h, getHandColor(s), 2);
            });
            hand.forEach((lm, i) => drawLandmark(canvasCtx, lm.x * w, lm.y * h, 4, getHandColor(i)));
          }
        });
      }

      // Fun Mode - detect and display gesture
      if (isFunMode) {
        const hand = results.rightHandLandmarks || results.leftHandLandmarks;
        const detectedGesture = recognizeGesture(hand);
        updateFunModeDisplay(detectedGesture);
      }

      canvasCtx.restore();
    }

    // Initialize
    // Detect mobile/iOS
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);

    statusValueEl.textContent = 'Loading model...';

    const holistic = new Holistic({
      locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/holistic/${file}`
    });

    // Use lower complexity on mobile for better performance
    holistic.setOptions({
      modelComplexity: isMobile ? 0 : 1,  // Lite model on mobile
      smoothLandmarks: true,
      enableSegmentation: false,
      refineFaceLandmarks: false,
      minDetectionConfidence: 0.5,
      minTrackingConfidence: 0.5
    });

    let modelLoaded = false;

    holistic.onResults((results) => {
      if (!modelLoaded) {
        modelLoaded = true;
        statusValueEl.textContent = 'Active';
        statusValueEl.classList.remove('loading');
        console.log('MediaPipe model loaded successfully!');
      }
      onResults(results);
    });

    // Show mobile warning if needed
    if (isIOS) {
      console.warn('iOS detected - MediaPipe may have limited support');
    }

    const camera = new Camera(videoElement, {
      onFrame: async () => {
        try {
          await holistic.send({ image: videoElement });
        } catch (e) {
          console.error('MediaPipe error:', e);
        }
      },
      width: isMobile ? 320 : 560,
      height: isMobile ? 240 : 420
    });

    // Set timeout for model loading
    const loadTimeout = setTimeout(() => {
      if (!modelLoaded) {
        statusValueEl.textContent = 'Slow load...';
        // Show help message
        const helpMsg = document.createElement('div');
        helpMsg.style.cssText = 'position:fixed;bottom:20px;left:50%;transform:translateX(-50%);background:rgba(239,68,68,0.9);color:white;padding:15px 25px;border-radius:10px;font-size:14px;z-index:1000;text-align:center;max-width:90%;';
        helpMsg.innerHTML = `
          <strong>‚ö†Ô∏è Model Loading Slow</strong><br>
          ${isIOS ? 'iOS Safari may have limited support for MediaPipe.<br>Try Chrome on Android or desktop for best results.' : 'Please wait or try refreshing the page.'}
        `;
        document.body.appendChild(helpMsg);
        setTimeout(() => helpMsg.remove(), 10000);
      }
    }, 15000);

    camera.start()
      .then(() => {
        console.log('Camera started successfully');
        if (!modelLoaded) {
          statusValueEl.textContent = 'Loading AI...';
        }
      })
      .catch(err => {
        console.error('Camera error:', err);
        statusValueEl.textContent = 'Camera Error';
        statusValueEl.classList.remove('loading');

        // Show error message
        const errorMsg = document.createElement('div');
        errorMsg.style.cssText = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(239,68,68,0.95);color:white;padding:25px;border-radius:15px;font-size:16px;z-index:1000;text-align:center;max-width:90%;';
        errorMsg.innerHTML = `
          <strong>üì∑ Camera Access Denied</strong><br><br>
          Please allow camera access and refresh the page.<br>
          <small>Error: ${err.message || err}</small>
        `;
        document.body.appendChild(errorMsg);
      });

    // Init reference canvas
    referenceCtx.fillStyle = 'rgba(15, 12, 41, 0.95)';
    referenceCtx.fillRect(0, 0, referenceCanvas.width, referenceCanvas.height);
    referenceCtx.fillStyle = '#a0aec0';
    referenceCtx.font = '12px Segoe UI';
    referenceCtx.textAlign = 'center';
    referenceCtx.fillText('Load a gesture JSON', referenceCanvas.width / 2, referenceCanvas.height / 2);
  </script>
</body>

</html>